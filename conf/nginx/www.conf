# Cache config
proxy_cache_path /var/cache/nginx levels=1:2 keys_zone=WEBSITE:100m inactive=60m use_temp_path=off;
proxy_cache_key "$scheme$request_method$host$request_uri";

map $http_cookie $skip_cache {
    default                     0;
    ~*wordpress_logged_in       1;
    ~*wp-postpass               1;
    ~*wp-resetpass              1;
}
map $request_method $cache_bypass {
    GET     0;
    HEAD    0;
    default 1;
}

# Cấu hình jwt
map $uri $jwt_required {
    ~^/api/config/                   0;
    ~^/api/investing/v1/ohcl/        0;
    ~^/api/chat/v1/facebook/webhook  0;
    ~^/api/ecommerce/v1/wms/shelves  1;
    default                          2;
}

server {
    server_name %%HTTP_SERVER%%;
    listen 8080;

    resolver 1.1.1.1 8.8.8.8 valid=300s;
    resolver_timeout 10s;

    root /var/www/html;
    index index.html index.php;

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    add_header X-XSS-Protection "1; mode=block" always;

    # Disallow methods except GET|POST|PUT|PATCH|HEAD
    if ($request_method !~ ^(GET|POST|PUT|PATCH|HEAD)$) {
        return 405;
    }

    # General PHP / WooCommerce
    location ~ \.php$ {
        proxy_pass http://%%WOOCOMMERCE_SERVER%%;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        proxy_cache WEBSITE;
        proxy_cache_bypass $skip_cache $cache_bypass;
        proxy_no_cache $skip_cache $cache_bypass;
        proxy_cache_valid 200 301 302 60m;
        proxy_cache_use_stale error timeout invalid_header updating;
        add_header X-Cache-Status $upstream_cache_status;
    }

    # WordPress admin/login/api → skip cache
    location ~* /(wp-admin|wp-login\.php|wp-json/|xmlrpc\.php) {
        proxy_pass http://%%WOOCOMMERCE_SERVER%%;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass 1;
        proxy_no_cache 1;
    }

    # Healthcheck
    location /health {
        proxy_pass http://127.0.0.1:%%SERVER_PORT%%/health;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        access_log off;
    }

    # Endpoint để khởi tạo đăng nhập
    location /login {
        access_by_lua_block {
            local openidc = require("resty.openidc")
            local cjson = require("cjson")

            local opts = {
                discovery = os.getenv("OIDC_ISSUER") .. "/.well-known/openid-configuration",
                client_id = os.getenv("OIDC_CLIENT_ID"),
                client_secret = os.getenv("OIDC_CLIENT_SECRET"),
                redirect_uri = "https://" .. ngx.var.host .. "/callback",
                scope = "openid email profile",
                token_signing_alg_values_expected = {"RS256"},
                ssl_verify = "yes",
                accept_none_alg = false,
                accept_unsupported_alg = false,
                cache_segment = 'auth0',
                session_contents = {id_token=true, user=true, access_token=true}
            }

            local session_opts = {
                cookie_http_only = true,
                cookie_secure = true,
                cookie_same_site = "Lax",
                remember = true,
                secret = os.getenv("OIDC_SESSION_SECRET"),
                storage = "redis",
                redis = {
                    host = os.getenv("REDIS_HOST"),   -- hoặc hostname Redis
                    username = os.getenv("REDIS_USERNAME"),
                    password = os.getenv("REDIS_PASSWORD"),
                    port = tonumber(os.getenv("REDIS_PORT")),
                    db = 0,
                    connect_timeout = 500,  -- ms
                    read_timeout = 2000,    -- ms
                    send_timeout = 2000     -- ms
                }
            }

            -- start login
            local res, err = openidc.authenticate(opts, nil, nil, session_opts)
            if err then
                ngx.log(ngx.ERR, "Login initiation failed: " .. err)
                ngx.header["Content-Type"] = "application/json"
                ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
                return ngx.say(cjson.encode({ error = "Login initiation failed: " .. err }))
            end
            ngx.redirect("/")
        }
    }

    # Logout endpoint
    location /logout {
        access_by_lua_block {
            local openidc = require("resty.openidc")
            local cjson = require("cjson")
            local opts = {
                discovery = os.getenv("OIDC_ISSUER") .. "/.well-known/openid-configuration",
                client_id = os.getenv("OIDC_CLIENT_ID"),
                client_secret = os.getenv("OIDC_CLIENT_SECRET"),
                redirect_after_logout_uri = "https://" .. ngx.var.host .. "/",
                scope = "openid email profile",
                token_signing_alg_values_expected = {"RS256"},
                ssl_verify = "yes",
                accept_none_alg = false,
                accept_unsupported_alg = false,
                cache_segment = 'auth0'
            }
            local session_opts = {
                cookie_http_only = true,
                cookie_secure = true,
                cookie_same_site = "Lax",
                remember = true,
                secret = os.getenv("OIDC_SESSION_SECRET"),
                storage = "redis",
                redis = {
                    host = os.getenv("REDIS_HOST"),   -- hoặc hostname Redis
                    username = os.getenv("REDIS_USERNAME"),
                    password = os.getenv("REDIS_PASSWORD"),
                    port = tonumber(os.getenv("REDIS_PORT")),
                    db = 0,
                    connect_timeout = 500,  -- ms
                    read_timeout = 2000,    -- ms
                    send_timeout = 2000     -- ms
                }
            }
            local session = require("resty.session").open(session_opts)
            if session.present and session.data.id_token then
                ngx.log(ngx.DEBUG, "Valid session found, redirecting to /")
                ngx.redirect("/")
                return
            end

            local res, err = openidc.authenticate(opts, nil, "logout", session_opts)
            if err then
                ngx.log(ngx.ERR, "Logout failed: " .. err)
                ngx.header["Content-Type"] = "application/json"
                ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
                return ngx.say(cjson.encode({ error = "Logout failed: " .. err }))
            end
            -- Chuyển hướng sau khi đăng xuất
            ngx.redirect("https://" .. ngx.var.host .. "/")
        }
    }

    # Callback endpoint
    location /callback {
        access_by_lua_block {
            local openidc = require("resty.openidc")
            local cjson = require("cjson")
            local opts = {
                discovery = os.getenv("OIDC_ISSUER") .. "/.well-known/openid-configuration",
                client_id = os.getenv("OIDC_CLIENT_ID"),
                client_secret = os.getenv("OIDC_CLIENT_SECRET"),
                redirect_uri = "https://" .. ngx.var.host .. "/callback",
                scope = "openid email profile",
                token_signing_alg_values_expected = {"RS256"},
                ssl_verify = "yes",
                accept_none_alg = false,
                accept_unsupported_alg = false,
                cache_segment = 'auth0',
                session_contents = {id_token=true, user=true, access_token=true}
            }

            local session_opts = {
                cookie_http_only = true,
                cookie_secure = true,
                cookie_same_site = "Lax",
                remember = true,
                secret = os.getenv("OIDC_SESSION_SECRET"),
                storage = "redis",
                redis = {
                    host = os.getenv("REDIS_HOST"),   -- hoặc hostname Redis
                    username = os.getenv("REDIS_USERNAME"),
                    password = os.getenv("REDIS_PASSWORD"),
                    port = tonumber(os.getenv("REDIS_PORT")),
                    db = 0,
                    connect_timeout = 500,  -- ms
                    read_timeout = 2000,    -- ms
                    send_timeout = 2000     -- ms
                }
            }

            local res, err, target = openidc.authenticate(opts, nil, nil, session_opts)
            if err then
                ngx.log(ngx.ERR, "Callback authentication failed: " .. err)
                ngx.header["Content-Type"] = "application/json"
                ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
                return ngx.say(cjson.encode({ error = "Callback authentication failed: " .. err }))
            end
            ngx.redirect(target or "/")
        }
    }

    # Internal APIs (Rust server)
    location /api/ {
	    access_by_lua_block {
            if ngx.var.jwt_required == "0" then
                return
            end

            local openidc = require("resty.openidc")
            local cjson = require("cjson")
            local jwks = require("resty.jwt-verification-jwks")
            local http = require("resty.http")

            -- === Lấy tenant_id từ cache hoặc API ===
            local tenant_id =  ngx.shared.tenant:get(ngx.var.host)
            if not tenant_id then
                local httpc = http.new()
                local res, err = httpc:request_uri(
                    "http://127.0.0.1:%%SERVER_PORT%%/api/config/v1/seo/tenant/" .. ngx.var.host .. "/id",
                    {
                        method = "GET",
                    }
                )

                if not res then
                    return ngx.say(cjson.encode({
                        error = "Fail to query tenant id of " .. ngx.var.host .. " by " .. ngx.var.remote_addr
                    }))
                else
                    ngx.shared.tenant:set(ngx.var.host, res.body, 600)
                end
            end
            ngx.req.set_header("X-Tenant-Id", ngx.shared.tenant:get(ngx.var.host))

            -- == Lấy authentication nếu có setup ===
            local auth_header = ngx.req.get_headers()["authorization"]
            if not auth_header then
	            if ngx.var.jwt_required == "2" then
	                ngx.header["Content-Type"] = "application/json"
                    ngx.status = ngx.HTTP_UNAUTHORIZED
                    return ngx.say(cjson.encode({
                        error = "Missing Authorization header for request from " .. ngx.var.remote_addr
                    }))
                end
            end

            if auth_header  then
                local jwt_token = auth_header:gsub("Bearer%s+", "")
                local issuer = os.getenv("OIDC_ISSUER") .. "/.well-known/jwks.json"

                local jwt_obj, err = jwks.verify_jwt_with_jwks(jwt_token, issuer)
                if not jwt_obj then
                    ngx.header["Content-Type"] = "application/json"
                    ngx.status = ngx.HTTP_UNAUTHORIZED
                    return ngx.say(cjson.encode({
                        error = "JWT verification failed: " .. err
                    }))
                end

                ngx.req.set_header("X-User-Id", jwt_obj.payload.sub)
                if jwt_obj.payload.email then
                    ngx.req.set_header("X-User-Email", jwt_obj.payload.email)
                end
            else
                -- === Falback về openid connect ===
                local opts = {
                    discovery = os.getenv("OIDC_ISSUER") .. "/.well-known/openid-configuration",  -- e.g., https://your-domain.auth0.com/.well-known/openid-configuration
                    client_id = os.getenv("OIDC_CLIENT_ID"),
                    client_secret = os.getenv("OIDC_CLIENT_SECRET"),
                    redirect_uri = "https://" .. ngx.var.host .. "/callback",  -- Cấu hình callback URL trong Auth0
                    scope = "openid email profile",
                    token_signing_alg_values_expected = {"RS256"},  -- Expect RS256 cho JWT verification (Auth0 default)
                    ssl_verify = "yes",
                    bearer_only = true,
                    accept_none_alg = false,
                    accept_unsupported_alg = false,
                    cache_segment = 'auth0',  -- Cache riêng cho location này
                    session_contents = {id_token=true, user=true, access_token=true}
                }

                local session_opts = {
                    cookie_http_only = true,
                    cookie_secure = true,
                    cookie_same_site = "Lax",
                    remember = true,
                    secret = os.getenv("OIDC_SESSION_SECRET"),  -- Secret cho session cookie
                    storage = "redis",
                    redis = {
                        host = os.getenv("REDIS_HOST"),   -- hoặc hostname Redis
                        username = os.getenv("REDIS_USERNAME"),
                        password = os.getenv("REDIS_PASSWORD"),
                        port = tonumber(os.getenv("REDIS_PORT")),
                        db = 0,
                        connect_timeout = 500,  -- ms
                        read_timeout = 2000,    -- ms
                        send_timeout = 2000     -- ms
                    }
                }

                -- Gọi authenticate cho OIDC
                local res, err, target, session = openidc.authenticate(opts, nil, nil, session_opts)

                if err then
                    ngx.log(ngx.ERR, "OIDC authentication failed: " .. err)
                    ngx.header["Content-Type"] = "application/json"
                    ngx.status = ngx.HTTP_UNAUTHORIZED
                    return ngx.say(cjson.encode({
                        error = "OIDC authentication failed: " .. err
                    }))
                end

                -- Xử lý nếu không có id_token (unauthenticated)
                if not res.id_token then
                    if ngx.var.jwt_required == "2" then
                        ngx.log(ngx.WARN, "Missing authorization for strict required request from " .. ngx.var.remote_addr)
                        ngx.header["Content-Type"] = "application/json"
                        ngx.status = ngx.HTTP_UNAUTHORIZED
                        return ngx.say(cjson.encode({
                            error = "Missing Authorization for request from " .. ngx.var.remote_addr
                        }))
                    else
                        -- Xử lý guest
                        ngx.req.set_header("X-Is-Guest", "true")
                        return
                    end
                end

                -- Kiểm tra issuer và audience để tăng bảo mật
                if res.id_token.iss ~= os.getenv("OIDC_ISSUER") .. "/" then
                    ngx.log(ngx.ERR, "Invalid issuer in token")
                    ngx.header["Content-Type"] = "application/json"
                    ngx.status = ngx.HTTP_UNAUTHORIZED
                    return ngx.say(cjson.encode({
                        error = "Invalid issuer (" .. res.id_token.iss .. " != " ..  os.getenv("OIDC_ISSUER") .. ")"
                    }))
                end
                if res.id_token.aud ~= os.getenv("OIDC_CLIENT_ID") then  -- Hoặc audience tùy chỉnh
                    ngx.log(ngx.ERR, "Invalid audience in token")
                    ngx.header["Content-Type"] = "application/json"
                    ngx.status = ngx.HTTP_UNAUTHORIZED
                    return ngx.say(cjson.encode({
                        error = "Invalid audience (" .. res.id_token.aud .. " != " .. os.getenv("OIDC_CLIENT_ID") .. ")"
                    }))
                end

                -- Set headers từ token
                ngx.req.set_header("X-User-Id", res.id_token.sub)
                if res.user and res.user.email then
                    ngx.req.set_header("X-User-Email", res.user.email)
                end
            end
        }

        proxy_pass http://127.0.0.1:%%SERVER_PORT%%;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Static website
    location = / {
	    access_by_lua_block {
            local http = require("resty.http")

            -- === Lấy tenant_id từ cache hoặc API ===
            local tenant_id =  ngx.shared.tenant:get(ngx.var.host)

            if not tenant_id then
                local httpc = http.new()
                local res, err = httpc:request_uri(
                    "http://127.0.0.1:%%SERVER_PORT%%/api/config/v1/seo/tenant/" .. ngx.var.host .. "/id",
                    {
                        method = "GET",
                    }
                )

                if not res then
                    return ngx.say(
                        "Fail to query tenant id of " .. ngx.var.host .. " by " .. ngx.var.remote_addr
                    )
                else
                    ngx.shared.tenant:set(ngx.var.host, res.body, 600)
                end
            end
            ngx.req.set_header("X-Tenant-Id", ngx.shared.tenant:get(ngx.var.host))
        }

        proxy_pass http://127.0.0.1:%%SERVER_PORT%%/api/config/v1/seo/files/index.html;

        proxy_set_header Host $host;
        proxy_set_header User-Agent $http_user_agent;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

        proxy_cache WEBSITE;
        proxy_cache_valid 200 30d;
        proxy_cache_bypass $skip_cache $cache_bypass;
        proxy_no_cache $skip_cache $cache_bypass;

        expires 30d;
	    allow all;
	    access_log off;

        add_header Cache-Control "public, max-age=2592000, immutable";
        add_header X-Cache-Status $upstream_cache_status;
        add_header Content-Type "text/html";
    }

    location ~* \.(?:jpg|jpeg|png|gif|ico|css|js|woff|woff2|ttf|svg|eot|otf|zip|pdf|docx|html|wasm?)$ {
	    access_by_lua_block {
            local http = require("resty.http")

            -- === Lấy tenant_id từ cache hoặc API ===
            local tenant_id =  ngx.shared.tenant:get(ngx.var.host)

            if not tenant_id then
                local httpc = http.new()
                local res, err = httpc:request_uri(
                    "http://127.0.0.1:%%SERVER_PORT%%/api/config/v1/seo/tenant/" .. ngx.var.host .. "/id",
                    {
                        method = "GET",
                    }
                )

                if not res then
                    return ngx.say(
                        "Fail to query tenant id of " .. ngx.var.host .. " by " .. ngx.var.remote_addr
                    )
                else
                    ngx.shared.tenant:set(ngx.var.host, res.body, 600)
                end
            end
            ngx.req.set_header("X-Tenant-Id", ngx.shared.tenant:get(ngx.var.host))
        }

        set $s3_content_type "application/octet-stream";

        if ($request_uri ~* \.(html)$) {
            set $s3_content_type "text/html";
        }
        if ($request_uri ~* \.(jpg|jpeg)$) {
            set $s3_content_type "image/jpeg";
        }
        if ($request_uri ~* \.png$) {
            set $s3_content_type "image/png";
        }
        if ($request_uri ~* \.gif$) {
            set $s3_content_type "image/gif";
        }
        if ($request_uri ~* \.ico$) {
            set $s3_content_type "image/x-icon";
        }
        if ($request_uri ~* \.css$) {
            set $s3_content_type "text/css";
        }
        if ($request_uri ~* \.js$) {
            set $s3_content_type "application/javascript";
        }
        if ($request_uri ~* \.wasm$) {
            set $s3_content_type "application/wasm";
        }
        if ($request_uri ~* \.(woff|woff2)$) {
            set $s3_content_type "font/woff2";
        }
        if ($request_uri ~* \.ttf$) {
            set $s3_content_type "font/ttf";
        }
        if ($request_uri ~* \.svg$) {
            set $_content_type "image/svg+xml";
        }
        if ($request_uri ~* \.eot$) {
            set $s3_content_type "application/vnd.ms-fontobject";
        }
        if ($request_uri ~* \.otf$) {
            set $s3_content_type "font/otf";
        }
        if ($request_uri ~* \.zip$) {
            set $s3_content_type "application/zip";
        }
        if ($request_uri ~* \.pdf$) {
            set $s3_content_type "application/pdf";
        }
        if ($request_uri ~* \.docx?$) {
            set $s3_content_type "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
        }

        proxy_pass http://127.0.0.1:%%SERVER_PORT%%/api/config/v1/seo/files$request_uri;

        proxy_set_header Host $host;
        proxy_set_header User-Agent $http_user_agent;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

        proxy_cache WEBSITE;
        proxy_cache_valid 200 30d;
        proxy_cache_bypass $skip_cache $cache_bypass;
        proxy_no_cache $skip_cache $cache_bypass;

        expires 30d;
	    allow all;
	    access_log off;

        add_header Cache-Control "public, max-age=2592000, immutable";
        add_header X-Cache-Status $upstream_cache_status;
        add_header Content-Type $s3_content_type;
    }

    # Misc
    location = /favicon.ico {
	    access_by_lua_block {
            local http = require("resty.http")

            -- === Lấy tenant_id từ cache hoặc API ===
            local tenant_id =  ngx.shared.tenant:get(ngx.var.host)

            if not tenant_id then
                local httpc = http.new()
                local res, err = httpc:request_uri(
                    "http://127.0.0.1:%%SERVER_PORT%%/api/config/v1/seo/tenant/" .. ngx.var.host .. "/id",
                    {
                        method = "GET",
                    }
                )

                if not res then
                    return ngx.say(
                        "Fail to query tenant id of " .. ngx.var.host .. " by " .. ngx.var.remote_addr
                    )
                else
                    ngx.shared.tenant:set(ngx.var.host, res.body, 600)
                end
            end
            ngx.req.set_header("X-Tenant-Id", ngx.shared.tenant:get(ngx.var.host))
        }

        proxy_pass http://127.0.0.1:%%SERVER_PORT%%/api/config/v1/seo/files/favicon.ico;
        proxy_set_header Host $host;
        proxy_set_header User-Agent $http_user_agent;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
	    access_log off;
	    log_not_found off;
    }
    location = /robots.txt  {
	    access_by_lua_block {
            local http = require("resty.http")

            -- === Lấy tenant_id từ cache hoặc API ===
            local tenant_id =  ngx.shared.tenant:get(ngx.var.host)

            if not tenant_id then
                local httpc = http.new()
                local res, err = httpc:request_uri(
                    "http://127.0.0.1:%%SERVER_PORT%%/api/config/v1/seo/tenant/" .. ngx.var.host .. "/id",
                    {
                        method = "GET",
                    }
                )

                if not res then
                    return ngx.say(
                        "Fail to query tenant id of " .. ngx.var.host .. " by " .. ngx.var.remote_addr
                    )
                else
                    ngx.shared.tenant:set(ngx.var.host, res.body, 600)
                end
            end
            ngx.req.set_header("X-Tenant-Id", ngx.shared.tenant:get(ngx.var.host))
        }

        proxy_pass http://127.0.0.1:%%SERVER_PORT%%/api/config/v1/seo/files/robots.txt;
        proxy_set_header Host $host;
        proxy_set_header User-Agent $http_user_agent;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
	    allow all;
	    access_log off;
	    log_not_found off;
    }
    location = /sitemap.xml {
	    access_by_lua_block {
            local http = require("resty.http")

            -- === Lấy tenant_id từ cache hoặc API ===
            local tenant_id =  ngx.shared.tenant:get(ngx.var.host)

            if not tenant_id then
                local httpc = http.new()
                local res, err = httpc:request_uri(
                    "http://127.0.0.1:%%SERVER_PORT%%/api/config/v1/seo/tenant/" .. ngx.var.host .. "/id",
                    {
                        method = "GET",
                    }
                )

                if not res then
                    return ngx.say(
                        "Fail to query tenant id of " .. ngx.var.host .. " by " .. ngx.var.remote_addr
                    )
                else
                    ngx.shared.tenant:set(ngx.var.host, res.body, 600)
                end
            end
            ngx.req.set_header("X-Tenant-Id", ngx.shared.tenant:get(ngx.var.host))
        }

        proxy_pass http://127.0.0.1:%%SERVER_PORT%%/api/config/v1/seo/sitemap;
        proxy_set_header Host $host;
        proxy_set_header User-Agent $http_user_agent;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
	    allow all;
        access_log off;
        log_not_found off;
    }
    location ~ /\.ht        { deny all; }
}
