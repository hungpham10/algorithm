//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.14

mod items;
mod lots;
mod sales;
mod shelves;
mod stock_entries;
mod stock_shelves;
mod stocks;

pub use items::Entity as Items;
pub use lots::Entity as Lots;
pub use sales::Entity as Sales;
pub use shelves::Entity as Shelves;
pub use stock_entries::Entity as StockEntries;
pub use stock_shelves::Entity as StockShelves;
pub use stocks::Entity as Stocks;

use std::collections::{HashMap, HashSet};
use std::sync::Arc;

use chrono::{DateTime, Utc};
use sea_orm::{
    ColumnTrait, DatabaseConnection, DbErr, EntityTrait, JoinType, QueryFilter, QueryOrder,
    QuerySelect, RuntimeErr,
};
use serde::{Deserialize, Serialize};

pub struct Wms {
    db: Arc<DatabaseConnection>,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct Stock {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<i32>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub shelves: Option<Vec<String>>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub lots: Option<Vec<Lot>>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub quantity: Option<i32>,

    pub name: String,
    pub unit: String,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct Lot {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<i32>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub entry_date: Option<DateTime<Utc>>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub cost_price: Option<f64>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub supplier: Option<String>,

    pub lot_number: String,
    pub quantity: i32,
}

impl Wms {
    pub fn new(db: Arc<DatabaseConnection>) -> Self {
        Self { db }
    }

    pub async fn create_stock(&self, tenant_id: i32, stock: &Stock) -> Result<i32, DbErr> {
        Err(DbErr::Query(RuntimeErr::Internal(format!(
            "Not implemented"
        ))))
    }

    pub async fn get_stock(&self, tenant_id: i32, stock_id: i32) -> Result<Stock, DbErr> {
        let result = Stocks::find()
            .filter(stocks::Column::TenantId.eq(tenant_id))
            .filter(stocks::Column::Id.eq(stock_id))
            .one(&*self.db)
            .await?;

        if let Some(result) = result {
            Ok(Stock {
                id: Some(result.id),
                quantity: Some(result.quantity),
                name: result.name.clone(),
                unit: result.unit.clone(),
                lots: None,
                shelves: None,
            })
        } else {
            Err(DbErr::Query(RuntimeErr::Internal(format!(
                "Stock with id {}, not exist",
                stock_id
            ))))
        }
    }

    pub async fn list_paginated_stocks(
        &self,
        tenant_id: i32,
        include_details: bool,
        after: i32,
        limit: u64,
    ) -> Result<Vec<Stock>, DbErr> {
        if include_details {
            #[derive(sea_orm::FromQueryResult)]
            struct StockQueryResult {
                id: i32,
                name: String,
                quantity: i32,
                unit: String,
                shelve_name: Option<String>,
                lot_id: Option<i32>,
                lot_number: Option<String>,
                lot_quantity: Option<i32>,
                lot_entry_date: Option<DateTime<Utc>>,
            }

            let items = Stocks::find()
                .select_only()
                .column(stocks::Column::Id)
                .column(stocks::Column::Name)
                .column(stocks::Column::Unit)
                .column(stocks::Column::Quantity)
                .column_as(shelves::Column::Name, "shelve_name")
                .column_as(lots::Column::Id, "lot_id")
                .column_as(lots::Column::LotNumber, "lot_number")
                .column_as(lots::Column::Quantity, "lot_quantity")
                .column_as(lots::Column::EntryDate, "lot_entry_date")
                .filter(stocks::Column::TenantId.eq(tenant_id))
                .filter(stocks::Column::Id.gt(after))
                .order_by_asc(stocks::Column::Id)
                .limit(limit)
                .join_rev(
                    JoinType::LeftJoin,
                    items::Entity::belongs_to(Stocks)
                        .from(items::Column::StockId)
                        .to(stocks::Column::Id)
                        .into(),
                )
                .join_rev(
                    JoinType::LeftJoin,
                    stock_shelves::Entity::belongs_to(Items)
                        .from(stock_shelves::Column::ItemId)
                        .to(items::Column::Id)
                        .into(),
                )
                .join_rev(
                    JoinType::LeftJoin,
                    shelves::Entity::belongs_to(StockShelves)
                        .from(shelves::Column::Id)
                        .to(stock_shelves::Column::ShelfId)
                        .into(),
                )
                .join_rev(
                    JoinType::LeftJoin,
                    lots::Entity::belongs_to(Items)
                        .from(lots::Column::Id)
                        .to(items::Column::LotId)
                        .into(),
                )
                .order_by_asc(shelves::Column::Name)
                .order_by_asc(lots::Column::Id)
                .into_model::<StockQueryResult>()
                .all(&*self.db)
                .await?;

            let mut stock_map: HashMap<i32, Stock> = HashMap::new();

            for item in items {
                let stock_id = item.id;

                let stock = stock_map.entry(stock_id).or_insert(Stock {
                    id: Some(item.id),
                    quantity: Some(item.quantity),
                    shelves: Some(Vec::new()),
                    lots: Some(Vec::new()),
                    name: item.name,
                    unit: item.unit,
                });

                if let Some(shelve_name) = item.shelve_name {
                    if let Some(shelves) = stock.shelves.as_mut() {
                        if !shelves.contains(&shelve_name) {
                            shelves.push(shelve_name.clone());
                        }
                    }
                }

                if let (lot_id, Some(lot_number), Some(lot_quantity), lot_entry_date) = (
                    item.lot_id,
                    item.lot_number,
                    item.lot_quantity,
                    item.lot_entry_date,
                ) {
                    if let Some(lots) = stock.lots.as_mut() {
                        if !lots.iter().any(|lot| lot.id == lot_id) {
                            lots.push(Lot {
                                lot_number,
                                id: lot_id,
                                quantity: lot_quantity,
                                entry_date: lot_entry_date,
                                cost_price: None,
                                supplier: None,
                                status: None,
                            });
                        }
                    }
                }
            }

            let stocks: Vec<Stock> = stock_map
                .into_values()
                .map(|mut stock| {
                    if let Some(shelves) = stock.shelves.as_mut() {
                        if shelves.is_empty() {
                            stock.shelves = None;
                        }
                    }
                    if let Some(lots) = stock.lots.as_mut() {
                        if lots.is_empty() {
                            stock.lots = None;
                        }
                    }
                    stock
                })
                .collect();

            Ok(stocks)
        } else {
            Ok(Stocks::find()
                .filter(stocks::Column::TenantId.eq(tenant_id))
                .filter(stocks::Column::Id.gt(after))
                .order_by_asc(stocks::Column::Id)
                .limit(limit)
                .all(&*self.db)
                .await?
                .iter()
                .map(|it| Stock {
                    id: Some(it.id),
                    quantity: Some(it.quantity),
                    name: it.name.clone(),
                    unit: it.unit.clone(),
                    lots: None,
                    shelves: None,
                })
                .collect::<Vec<_>>())
        }
    }

    pub async fn get_lot(&self, tenant_id: i32, lot_id: i32) -> Result<Lot, DbErr> {
        let result = Lots::find()
            .filter(lots::Column::TenantId.eq(tenant_id))
            .filter(lots::Column::Id.eq(lot_id))
            .one(&*self.db)
            .await?;

        if let Some(result) = result {
            Ok(Lot {
                id: Some(result.id),
                entry_date: Some(result.entry_date),
                lot_number: result.lot_number.to_string(),
                quantity: result.quantity,
                cost_price: result.cost_price,
                supplier: result.supplier.clone(),
                status: result.status.clone(),
            })
        } else {
            Err(DbErr::Query(RuntimeErr::Internal(format!(
                "Lot with id {}, not exist",
                lot_id
            ))))
        }
    }

    pub async fn list_paginated_lots_of_stock(
        &self,
        tenant_id: i32,
        stock_id: i32,
        after: i32,
        limit: u64,
    ) -> Result<Vec<Lot>, DbErr> {
        Ok(Lots::find()
            .filter(lots::Column::TenantId.eq(tenant_id))
            .filter(lots::Column::StockId.eq(stock_id))
            .filter(lots::Column::Id.gt(after))
            .order_by_asc(lots::Column::Id)
            .limit(limit)
            .all(&*self.db)
            .await?
            .iter()
            .map(|it| Lot {
                id: Some(it.id),
                entry_date: Some(it.entry_date),
                lot_number: it.lot_number.to_string(),
                quantity: it.quantity,
                cost_price: it.cost_price,
                supplier: it.supplier.clone(),
                status: it.status.clone(),
            })
            .collect::<Vec<_>>())
    }
}
