//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.14
mod brokers;
mod products;
use brokers::Entity as Brokers;
use products::Entity as Products;

use std::sync::Arc;

use sea_orm::{
    ColumnTrait, Condition, DatabaseConnection, DbErr, EntityTrait, JoinType, QueryFilter,
    QuerySelect,
};

pub struct Ohcl {
    db: Arc<DatabaseConnection>,
}

impl Ohcl {
    pub fn new(db: Arc<DatabaseConnection>) -> Self {
        Self { db }
    }

    pub async fn list_brokers(&self, after: i32, limit: u64) -> Result<(Vec<String>, i32), DbErr> {
        let items = Brokers::find()
            .filter(brokers::Column::Id.gt(after))
            .limit(limit)
            .all(&*self.db)
            .await?;

        Ok((
            items.iter().map(|it| it.name.clone()).collect::<Vec<_>>(),
            match items.last() {
                Some(item) => item.id,
                None => 0,
            },
        ))
    }

    pub async fn is_product_enabled(
        &self,
        product: &String,
        broker: &String,
    ) -> Result<bool, DbErr> {
        let res = Products::find()
            .join_rev(
                JoinType::InnerJoin,
                products::Entity::belongs_to(Brokers)
                    .from(products::Column::BrokerId)
                    .to(brokers::Column::Id)
                    .into(),
            )
            .filter(
                Condition::all()
                    .add(products::Column::Name.eq(product))
                    .add(brokers::Column::Name.eq(broker))
                    .add(products::Column::Enabled.eq(true)),
            )
            .one(&*self.db)
            .await?;

        Ok(res.is_some())
    }
}
