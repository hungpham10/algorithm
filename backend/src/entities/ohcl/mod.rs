//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.14
mod brokers;
mod mapping_broker_resolution;
mod products;
mod resolutions;
use brokers::Entity as Brokers;
use mapping_broker_resolution::Entity as MappingBrokerResolution;
use products::Entity as Products;
use resolutions::Entity as Resolutions;

use std::sync::Arc;

use sea_orm::{
    ColumnTrait, Condition, DatabaseConnection, DbErr, EntityTrait, JoinType, QueryFilter,
    QuerySelect, RuntimeErr,
};

pub struct Ohcl {
    db: Arc<DatabaseConnection>,
}

impl Ohcl {
    pub fn new(db: Arc<DatabaseConnection>) -> Self {
        Self { db }
    }

    pub async fn convert_to_broker_resolution(
        &self,
        broker: &String,
        resolution: &String,
    ) -> Result<String, DbErr> {
        let res: Option<String> = MappingBrokerResolution::find()
            .join_rev(
                JoinType::InnerJoin,
                brokers::Entity::belongs_to(MappingBrokerResolution)
                    .from(brokers::Column::Id)
                    .to(mapping_broker_resolution::Column::BrokerId)
                    .into(),
            )
            .join_rev(
                JoinType::InnerJoin,
                resolutions::Entity::belongs_to(MappingBrokerResolution)
                    .from(resolutions::Column::Id)
                    .to(mapping_broker_resolution::Column::ResolutionId)
                    .into(),
            )
            .filter(brokers::Column::Name.eq(broker))
            .filter(resolutions::Column::Resolution.eq(resolution))
            .select_only()
            .column(mapping_broker_resolution::Column::Resolution)
            .into_tuple::<String>()
            .one(&*self.db)
            .await?;

        match res {
            Some(res) => Ok(res),
            None => Err(DbErr::Query(RuntimeErr::Internal(format!(
                "Resolution {} is not supported for {}",
                resolution, broker
            )))),
        }
    }

    pub async fn list_resolutions(&self) -> Result<Vec<String>, DbErr> {
        Ok(Resolutions::find()
            .select_only()
            .column(resolutions::Column::Resolution)
            .into_tuple::<String>()
            .all(&*self.db)
            .await?)
    }

    pub async fn list_brokers(&self, after: i32, limit: u64) -> Result<(Vec<String>, i32), DbErr> {
        let items = Brokers::find()
            .filter(brokers::Column::Id.gt(after))
            .limit(limit)
            .all(&*self.db)
            .await?;

        Ok((
            items.iter().map(|it| it.name.clone()).collect::<Vec<_>>(),
            match items.last() {
                Some(item) => item.id,
                None => 0,
            },
        ))
    }

    pub async fn is_broker_enabled(&self, broker: &String) -> Result<bool, DbErr> {
        Ok(Brokers::find()
            .filter(brokers::Column::Name.eq(broker))
            .one(&*self.db)
            .await?
            .is_some())
    }

    pub async fn is_product_enabled(
        &self,
        product: &String,
        broker: &String,
    ) -> Result<bool, DbErr> {
        let res = Products::find()
            .join_rev(
                JoinType::InnerJoin,
                brokers::Entity::belongs_to(Products)
                    .from(brokers::Column::Id)
                    .to(products::Column::BrokerId)
                    .into(),
            )
            .filter(
                Condition::all()
                    .add(products::Column::Name.eq(product))
                    .add(brokers::Column::Name.eq(broker))
                    .add(products::Column::Enabled.eq(1)),
            )
            .one(&*self.db)
            .await?;

        Ok(res.is_some())
    }
}
